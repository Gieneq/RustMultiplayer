use clap::{
    Parser, 
    Subcommand, 
    Args
};

use rust_multiplayer::DEFAULT_SERVER_ADRESS;

/// # Global Arguments
#[derive(Debug, Parser)]
#[command(version, about = "Multiplayer game", long_about = None)]
struct Cli {
    #[command(subcommand)]
    mode: Mode,
}

#[derive(Debug, Subcommand)]
enum Mode {
    /// Run server
    Server(ServerArgs),

    /// Request server
    Request(RequestArgs),

    /// Run player cleint app
    Player(PlayerClientArgs)
}

#[derive(Debug, Args)]
struct ServerArgs {
    /// Server address
    #[arg(short = 'a', long = "address", value_name = "SERVER_ADDRESS", default_value_t = String::from(DEFAULT_SERVER_ADRESS))]
    address: String,
}

#[derive(Debug, Args)]
struct RequestArgs {
    /// Server address
    #[arg(short = 'a', long = "address", value_name = "SERVER_ADDRESS", default_value_t = String::from(DEFAULT_SERVER_ADRESS))]
    address: String,
}

#[derive(Debug, Args)]
struct PlayerClientArgs {
    /// Server address
    #[arg(short = 'a', long = "address", value_name = "SERVER_ADDRESS", default_value_t = String::from(DEFAULT_SERVER_ADRESS))]
    address: String,
    
    /// Player name, if not provided autogenerated will be set
    #[arg(short = 'n', long = "name", value_name = "PLAYER_NAME", required = false)]
    player_name: Option<String>,
}

fn main() {
    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or("debug"))
        .format_timestamp_millis()
        .format_file(false)
        .format_line_number(true)
        .init();

    let cli_args = Cli::parse();
    log::info!("Got args: '{:?}'.", cli_args);
    
    match cli_args.mode {
        Mode::Server(server_args) => {
            cli_server::run(&server_args.address);
        },
        Mode::Request(request_args) => {
            cli_request::run(&request_args.address);
        },
        Mode::Player(player_client_args) => {
            cli_player_client::run(
                &player_client_args.address, 
                player_client_args.player_name
            );
        },
    }
}

mod cli_server {
    use rust_multiplayer::app::server::MultiplayerServer;

    pub fn run<A: tokio::net::ToSocketAddrs>(addr: A) {
        let rt = tokio::runtime::Runtime::new().unwrap();
        rt.block_on(async {
            let server = MultiplayerServer::bind(addr).await.unwrap();
            log::info!("MP-server, address:{:?}",  server.get_local_address().unwrap());
            
            let server_handler = server.run().await.unwrap();

            let (ctrlc_sender, ctrlc_receiver) = tokio::sync::oneshot::channel();
            let mut ctrlc_sender = Some(ctrlc_sender);

            ctrlc::set_handler(move || {
                log::info!("Captured ctrl-C, shutting down the server...");
                let sndr = ctrlc_sender.take().unwrap();
                sndr.send(()).unwrap();
            }).expect("Error setting Ctrl-C handler");

            ctrlc_receiver.await.unwrap();
            server_handler.shutdown().await.unwrap();
        })
    }
}

mod cli_request {
    use tokio::io::{AsyncBufReadExt, AsyncWriteExt};

    use tokio::net::TcpStream;
    use std::net::SocketAddr;


    async fn client_do_request_await_response(
        req: &str,
        buf_reader: &mut tokio::io::BufReader<tokio::net::tcp::ReadHalf<'_>>,
        write: &mut tokio::net::tcp::WriteHalf<'_>,
    ) -> String {
        let mut buf_string = String::new();

        write.write_all(req.as_bytes()).await.unwrap();
        write.write_all(b"\n").await.unwrap();
        write.flush().await.unwrap();

        buf_reader.read_line(&mut buf_string).await.unwrap();
        buf_string.trim().to_string()
    }

    pub fn run<A: tokio::net::ToSocketAddrs + std::fmt::Display>(addr: A) {
        let rt = tokio::runtime::Runtime::new().unwrap();

        rt.block_on(async move {
            log::info!("Client attempts to connect to server {addr}...");

            let mut socket = TcpStream::connect(addr).await.unwrap();
            let client_address: SocketAddr = socket.local_addr().unwrap();
            log::info!("Client {client_address} connected!");

            let (read_half, mut write_half) = socket.split();
            let mut buf_reader = tokio::io::BufReader::new(read_half);

            let requests = [
                String::from("{\"type\":\"Healthcheck\"}"),
                String::from("{\"type\":\"GetId\"}"),
                String::from("{\"type\":\"WorldCheck\"}"),
            ];

            for request in requests {
                let response = client_do_request_await_response(
                    &request,
                    &mut buf_reader,
                    &mut write_half,
                ).await;

                println!("'{request}' -> '{response}'");
            }
        });
    }
}

mod cli_player_client {
    use rust_multiplayer::{
        app::client::{
            gui_client::{
                guis::{AppGui, GuiLayout}, renderer::Renderer, AppData
            }, 
            MultiplayerClient
        }, game::math::Vector2F
        
    };

    use std::{
        cell::RefCell, 
        rc::Rc, 
        sync::Arc, 
        time::Instant
    };

    use winit::{
        application::ApplicationHandler, 
        dpi::{
            PhysicalPosition, 
            PhysicalSize
        }, 
        event::WindowEvent, 
        event_loop::{
            ActiveEventLoop, 
            ControlFlow, 
            EventLoop
        }, window::{
            Window, 
            WindowId
        }
    };

    const INITIAL_WINDOW_SIZE: Vector2F = Vector2F { x: 800.0, y: 600.0 };

    struct App {
        renderer: Option<Renderer>,
        last_draw_time: Instant,
        last_cursor_position: PhysicalPosition<f64>,    
        active_app_gui: AppGui,
        app_data: Rc<RefCell<AppData>>,
    }

    impl ApplicationHandler for App {

        fn resumed(&mut self, event_loop: &ActiveEventLoop) {
            // Create window object
            let window = Arc::new(
                event_loop
                    .create_window(Window::default_attributes())
                    .unwrap(),
            );

            let _ = window.request_inner_size(PhysicalSize::new(INITIAL_WINDOW_SIZE.x, INITIAL_WINDOW_SIZE.y));
            {
                let mut app_data = self.app_data.borrow_mut();
                app_data.last_width = INITIAL_WINDOW_SIZE.x;
                app_data.last_height = INITIAL_WINDOW_SIZE.y;
            }

            let renderer = pollster::block_on(Renderer::new(window.clone()));
            self.renderer = Some(renderer);

            window.request_redraw();
        }

        fn window_event(&mut self, event_loop: &ActiveEventLoop, _id: WindowId, event: WindowEvent) {
            let renderer = self.renderer.as_mut().unwrap();

            match event {
                WindowEvent::CloseRequested => {
                    println!("The close button was pressed; stopping");
                    event_loop.exit();

                    let client_handler = self.app_data.borrow_mut().client_handler.take().unwrap();
                    client_handler.wait_until_finished().unwrap()
                }
                WindowEvent::RedrawRequested => {
                    const TARGET_FRAME_INTERVAL: std::time::Duration = std::time::Duration::from_millis(33);

                    let now = Instant::now();
                    let dt = now.duration_since(self.last_draw_time);

                    {
                        let app_data = self.app_data.borrow();
                        renderer.batch_set_camera(app_data.camera, app_data.world_scale);
                    }

                    {
                        // Check if should make transition
                        let next_app_gui = {
                            let mut app_data = self.app_data.borrow_mut();
                            app_data.app_gui_expected_transition.take()
                        };

                        if let Some(next_app_gui) = next_app_gui {
                            self.active_app_gui.transition(next_app_gui);
                        }
                    }

                    if dt >= TARGET_FRAME_INTERVAL {
                        self.last_draw_time = now;
                        self.active_app_gui.update(dt);
    
                        renderer.batch_clear();
                        self.active_app_gui.draw(renderer);
                        renderer.render();
                    }

                    // Emits a new redraw requested event.
                    renderer.get_window().request_redraw();
                },
                WindowEvent::Resized(size) => {
                    // Reconfigures the size of the surface. We do not re-render
                    // here as this event is always followed up by redraw request.
                    {
                        let mut app_data = self.app_data.borrow_mut();
                        app_data.last_width = size.width as f32;
                        app_data.last_height = size.height as f32;
                    }

                    self.active_app_gui.resize_window(size.width as f32, size.height as f32);
                    renderer.resize(size);
                },
                WindowEvent::MouseWheel {
                    device_id: _, delta,  phase: _ } => {
                    self.active_app_gui.process_mouse_wheele(delta);
                },
                WindowEvent::KeyboardInput { device_id: _, event, is_synthetic: _ } => {
                    self.active_app_gui.process_key_event(event);  
                },
                WindowEvent::CursorMoved { position, .. } => {
                    self.last_cursor_position = position;
                    self.active_app_gui.mouse_move(Vector2F::new(position.x as f32, position.y as f32));  
                }
                WindowEvent::MouseInput { device_id: _, state, button } => {
                    self.active_app_gui.process_mouse_events(
                        self.last_cursor_position,
                        state,
                        button
                    )
                },
                _ => (),
            }
        }
    }

    pub fn run<A: std::net::ToSocketAddrs + std::fmt::Debug>(addr: A, player_name: Option<String>) {
        // wgpu uses `log` for all of our logging, so we initialize a logger with the `env_logger` crate.
        
        let event_loop = EventLoop::new().unwrap();

        // When the current loop iteration finishes, immediately begin a new
        // iteration regardless of whether or not new events are available to
        // process. Preferred for applications that want to render as fast as
        // possible, like games.
        event_loop.set_control_flow(ControlFlow::Poll);

        let client_handler = MultiplayerClient::connect(addr).unwrap()
            .run().unwrap();

        let app_data = Rc::new(RefCell::new(AppData { 
            client_handler: Some(client_handler),
            player_name,
            app_gui_expected_transition: None,
            last_width: INITIAL_WINDOW_SIZE.x,
            last_height: INITIAL_WINDOW_SIZE.y, 
            world_scale: 0.02,
            camera: Vector2F::zero(),
        }));

        let mut app = App {
            active_app_gui: AppGui::new(app_data.clone()),
            last_draw_time: Instant::now(),
            app_data,
            renderer: None,
            last_cursor_position: PhysicalPosition::new(0.0, 0.0),
        };
        
        // Client has no name so far, GUI remains default: not connected

        event_loop.run_app(&mut app).unwrap();
    }
}